-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A distributed data processing framework in pure Haskell
--   
--   A distributed data processing framework in pure Haskell
@package distributed-dataset
@version 0.0.1.0


-- | A utility module which lets you put a concurrency limit to an IO
--   action.
module Control.Concurrent.Throttled
data Throttle
newThrottle :: MonadIO m => Int -> m Throttle
throttled :: Throttle -> forall m a. (MonadIO m, MonadMask m) => m a -> m a

module Control.Distributed.Dataset.ShuffleStore

-- | Provides a way to store intermediate temporary data.
data ShuffleStore
ShuffleStore :: Closure (Int64 -> Range -> ConduitT () ByteString (ResourceT IO) ()) -> Closure (Int64 -> ConduitT ByteString Void (ResourceT IO) ()) -> ShuffleStore
[ssGet] :: ShuffleStore -> Closure (Int64 -> Range -> ConduitT () ByteString (ResourceT IO) ())
[ssPut] :: ShuffleStore -> Closure (Int64 -> ConduitT ByteString Void (ResourceT IO) ())
data Range
RangeAll :: Range
RangeOnly :: Integer -> Integer -> Range
instance Data.Binary.Class.Binary Control.Distributed.Dataset.ShuffleStore.Range
instance GHC.Generics.Generic Control.Distributed.Dataset.ShuffleStore.Range
instance GHC.Classes.Eq Control.Distributed.Dataset.ShuffleStore.Range
instance GHC.Show.Show Control.Distributed.Dataset.ShuffleStore.Range


-- | You only need this module if you want to create a new backend for
--   distributed-dataset.
module Control.Distributed.Fork.Backend

-- | <a>Backend</a> is responsible for running your functions in a remote
--   environment.
--   
--   Should run the current binary in the target environment, put the given
--   string as standard input and return the executables answer on the
--   standard output. | BackendM is essentially <a>IO</a>, but also has the
--   ability to report the status of the executor.
newtype Backend
Backend :: (ByteString -> BackendM ByteString) -> Backend
[bExecute] :: Backend -> ByteString -> BackendM ByteString
data BackendM a

-- | We switch to executor mode only when <tt>argv[1] ==
--   argExecutorMode</tt>.
argExecutorMode :: String
data ExecutorFinalStatus a
ExecutorFailed :: Text -> ExecutorFinalStatus a
ExecutorSucceeded :: a -> ExecutorFinalStatus a
data ExecutorStatus a
ExecutorPending :: ExecutorPendingStatus -> ExecutorStatus a
ExecutorFinished :: ExecutorFinalStatus a -> ExecutorStatus a
data ExecutorPendingStatus
ExecutorWaiting :: Maybe Text -> ExecutorPendingStatus
ExecutorSubmitted :: Maybe Text -> ExecutorPendingStatus
ExecutorStarted :: Maybe Text -> ExecutorPendingStatus
waiting :: BackendM ()
waitingDesc :: Text -> BackendM ()
submitted :: BackendM ()
submittedDesc :: Text -> BackendM ()
started :: BackendM ()
startedDesc :: Text -> BackendM ()
throttledBackend :: MonadIO m => Int -> Backend -> m Backend

-- | Given an IO action and a static proof that the result is
--   <a>Serializable</a>, this function runs the action using the Backend
--   in a separate thread and returns a <a>TVar</a> holding the
--   <a>ExecutorStatus</a>.
runBackend :: Closure (Dict (Serializable i)) -> Closure (IO i) -> Backend -> IO (Handle i)
toBackendStdin :: Closure (Dict (Serializable a)) -> Closure (IO a) -> ByteString
fromBackendStdout :: Binary a => ByteString -> ExecutorFinalStatus a

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Returns the absolute pathname of the current executable.
--   
--   Note that for scripts and interactive sessions, this is the path to
--   the interpreter (e.g. ghci.)
--   
--   Since base 4.11.0.0, <a>getExecutablePath</a> resolves symlinks on
--   Windows. If an executable is launched through a symlink,
--   <a>getExecutablePath</a> returns the absolute path of the original
--   executable.
getExecutablePath :: IO FilePath

module Control.Distributed.Fork.Local

-- | A <a>Backend</a> which uses local processes as executors. Useful for
--   testing.
localProcessBackend :: Backend

module Control.Distributed.Dataset.Local

-- | Uses a temporary directory in the local disk as a <a>ShuffleStore</a>.
withLocalTmpShuffleStore :: (ShuffleStore -> IO a) -> IO a

-- | A <a>Backend</a> which uses local processes as executors. Useful for
--   testing.
localProcessBackend :: Backend


-- | This module provides a common interface for offloading an IO action to
--   remote executors.
module Control.Distributed.Fork

-- | Asynchronously executes the given function using the <a>Backend</a>
--   and returns an <a>Handle</a>.
fork :: MonadIO m => Backend -> Closure (Dict (Serializable a)) -> Closure (IO a) -> m (Handle a)

-- | On distributed-fork, we run the same binary both in your machine
--   (called "driver") and in the remote environment (called "executor").
--   In order for the program to act according to where it is, you should
--   call this function as the first thing in your <tt>main</tt>:
initDistributedFork :: IO ()

-- | <a>Backend</a> is responsible for running your functions in a remote
--   environment.
--   
--   Should run the current binary in the target environment, put the given
--   string as standard input and return the executables answer on the
--   standard output. | BackendM is essentially <a>IO</a>, but also has the
--   ability to report the status of the executor.
data Backend

-- | Result of a <tt>fork</tt> is an Handle where you can <tt>await</tt> a
--   result.
data Handle a

-- | Blocks until the <a>Handle</a> completes.
await :: (MonadIO m, MonadThrow m) => Handle a -> m a

-- | Get the current status of given <a>Handle</a>.
pollHandle :: Handle a -> STM (ExecutorStatus a)
data ExecutorStatus a
ExecutorPending :: ExecutorPendingStatus -> ExecutorStatus a
ExecutorFinished :: ExecutorFinalStatus a -> ExecutorStatus a
data ExecutorPendingStatus
ExecutorWaiting :: Maybe Text -> ExecutorPendingStatus
ExecutorSubmitted :: Maybe Text -> ExecutorPendingStatus
ExecutorStarted :: Maybe Text -> ExecutorPendingStatus
data ExecutorFinalStatus a
ExecutorFailed :: Text -> ExecutorFinalStatus a
ExecutorSucceeded :: a -> ExecutorFinalStatus a
newtype ExecutorFailedException
ExecutorFailedException :: Text -> ExecutorFailedException

-- | Values that can be sent across the network.
type Serializable a = (Binary a, Typeable a)

-- | Type of serializable closures. Abstractly speaking, a closure is a
--   code reference paired together with an environment. A serializable
--   closure includes a <i>shareable</i> code reference (i.e. a
--   <a>StaticPtr</a>). Closures can be serialized only if all expressions
--   captured in the environment are serializable.
data Closure a

-- | Closure application. Note that <a>Closure</a> is not a functor, let
--   alone an applicative functor, even if it too has a meaningful notion
--   of application.
cap :: Typeable a => Closure (a -> b) -> Closure a -> Closure b

-- | A closure can be created from any serializable value. <a>cpure</a>
--   corresponds to <a>Control.Applicative</a>'s <a>pure</a>, but
--   restricted to lifting serializable values only.
cpure :: Closure (Dict (Serializable a)) -> a -> Closure a

-- | Values of type <tt><a>Dict</a> p</tt> capture a dictionary for a
--   constraint of type <tt>p</tt>.
--   
--   e.g.
--   
--   <pre>
--   <a>Dict</a> :: <a>Dict</a> (<a>Eq</a> <a>Int</a>)
--   </pre>
--   
--   captures a dictionary that proves we have an:
--   
--   <pre>
--   instance <a>Eq</a> 'Int
--   </pre>
--   
--   Pattern matching on the <a>Dict</a> constructor will bring this
--   instance into scope.
data Dict a
[Dict] :: forall a. a => Dict a
instance GHC.Classes.Eq Control.Distributed.Fork.ExecutorFailedException
instance GHC.Show.Show Control.Distributed.Fork.ExecutorFailedException
instance GHC.Exception.Type.Exception Control.Distributed.Fork.ExecutorFailedException

module Control.Distributed.Fork.Utils

-- | Runs given closures concurrently using the <a>Backend</a>, showing a
--   progress bar.
forkConcurrently :: Options -> Backend -> Closure (Dict (Serializable a)) -> [Closure (IO a)] -> IO [a]
data Options
Options :: Int -> Bool -> Options
[oRetries] :: Options -> Int
[oShowProgress] :: Options -> Bool
defaultOptions :: Options
instance GHC.Classes.Eq Control.Distributed.Fork.Utils.Progress
instance GHC.Base.Semigroup Control.Distributed.Fork.Utils.Progress
instance GHC.Base.Monoid Control.Distributed.Fork.Utils.Progress
instance Data.Group.Group Control.Distributed.Fork.Utils.Progress

module Control.Distributed.Dataset.Aggr

-- | Represent an aggregation which takes many <tt>a</tt>s and returns a
--   single <tt>b</tt>.
data Aggr a b

-- | An aggregation which ignores the input data and always yields the
--   given value.
aggrConst :: forall a t. (Typeable a, Typeable t) => Closure a -> Aggr t a

-- | Returns the number of inputs.
aggrCount :: Typeable a => Aggr a Integer

-- | Returns the sum of the inputs.
aggrSum :: StaticSerialise a => Closure (Dict (Num a)) -> Aggr a a

-- | Calculates the mean of the inputs.
aggrMean :: Aggr Double Double

-- | Return the maximum of the inputs.
aggrMax :: StaticSerialise a => Closure (Dict (Ord a)) -> Aggr a (Maybe a)

-- | Return the minimum of the inputs.
aggrMin :: StaticSerialise a => Closure (Dict (Ord a)) -> Aggr a (Maybe a)

-- | Collects the inputs as a list.
aggrCollect :: StaticSerialise a => Aggr a [a]

-- | Collects the inputs to a <a>HashSet</a>.
aggrDistinct :: forall a. (StaticSerialise a, StaticHashable a) => Aggr a (HashSet a)

-- | Returns the <tt>n</tt> greatest elements according to a key function.
--   Similar to: <tt>take n . sortOn (Down . f)</tt>
aggrTopK :: (StaticSerialise a, Typeable k) => Closure (Dict (Ord k)) -> Int -> Closure (a -> k) -> Aggr a [a]

-- | Returns the <tt>n</tt> least elements according to a key function.
--   Similar to: <tt>take n . sortOn (Down . f)</tt>
aggrBottomK :: (StaticSerialise a, Typeable k) => Closure (Dict (Ord k)) -> Int -> Closure (a -> k) -> Aggr a [a]

-- | Returns a new Aggr which only aggregates rows matching the predicate,
--   discarding others.
aggrFiltered :: Closure (a -> Bool) -> Aggr a b -> Aggr a b

-- | Create an aggregation given a <a>Monoid</a> instance.
aggrFromMonoid :: StaticSerialise a => Closure (Dict (Monoid a)) -> Aggr a a

-- | Create an aggregation given a reduce function.
aggrFromReduce :: StaticSerialise a => Closure (a -> a -> a) -> Aggr a (Maybe a)

-- | Create an aggregation given two <a>Fold</a>s.
aggrFromFold :: (StaticSerialise t, Typeable a, Typeable b) => Closure (Fold a t) -> Closure (Fold t b) -> Aggr a b
instance GHC.Base.Semigroup (Control.Distributed.Dataset.Aggr.TopK a)
instance GHC.Base.Monoid (Control.Distributed.Dataset.Aggr.TopK a)

module Control.Distributed.Dataset

-- | Represents a partitioned multiset that can be transformed in a
--   distributed fashion.
data Dataset a

-- | Returns a new Dataset that contains the result of applying the given
--   function to each element.
dMap :: (StaticSerialise a, StaticSerialise b) => Closure (a -> b) -> Dataset a -> Dataset b

-- | Returns a new Dataset that only contains elements where the given
--   function returns true.
dFilter :: StaticSerialise a => Closure (a -> Bool) -> Dataset a -> Dataset a

-- | Returns a new Dataset by first applying a function to all elements of
--   this Dataset, and then flattening the results.
dConcatMap :: (StaticSerialise a, StaticSerialise b) => Closure (a -> [b]) -> Dataset a -> Dataset b

-- | Apply an aggregation to all rows sharing the same key.
dGroupedAggr :: (StaticHashable k, StaticSerialise k, StaticSerialise b) => Int -> Closure (a -> k) -> Aggr a b -> Dataset a -> Dataset (k, b)

-- | Removes a new dataset with duplicate rows removed.
dDistinct :: StaticHashable a => Int -> Dataset a -> Dataset a

-- | Removes a new dataset with rows with the duplicate keys removed.
dDistinctBy :: StaticHashable b => Int -> Closure (a -> b) -> Dataset a -> Dataset a

-- | Coalesce partitions together to get the specified number of
--   partitions.
dCoalesce :: Typeable a => Int -> Dataset a -> Dataset a

-- | Transforms a <a>Dataset</a> by passing every partition through the
--   given Conduit.
dPipe :: (StaticSerialise a, StaticSerialise b) => Closure (ConduitT a b (ResourceT IO) ()) -> Dataset a -> Dataset b

-- | Re-partition the dataset using the given function so that the items
--   with the same <tt>k</tt> will end up in the same partition.
dPartition :: (StaticSerialise a, StaticHashable k) => Int -> Closure (a -> k) -> Dataset a -> Dataset a

-- | Apply an aggregation to all items on a Dataset, and fetch the result.
dAggr :: (StaticSerialise a, StaticSerialise b) => Aggr a b -> Dataset a -> DD b

-- | Returns a Conduit to fetch the results lazily to the driver.
dFetch :: StaticSerialise a => Dataset a -> DD (ConduitT () a (ResourceT IO) ())

-- | Fetches the complete dataset as a list.
dToList :: StaticSerialise a => Dataset a -> DD [a]
data DD a
runDD :: Backend -> ShuffleStore -> DD a -> IO a
runDDWith :: LogLevel -> Backend -> ShuffleStore -> DD a -> IO a

-- | <a>Backend</a> is responsible for running your functions in a remote
--   environment.
--   
--   Should run the current binary in the target environment, put the given
--   string as standard input and return the executables answer on the
--   standard output. | BackendM is essentially <a>IO</a>, but also has the
--   ability to report the status of the executor.
data Backend

-- | Provides a way to store intermediate temporary data.
data ShuffleStore

-- | Represents some amount of data which to be transformed on a single
--   executor.
data Partition a

-- | Create a <a>Partition</a> given a Source conduit.
mkPartition :: Typeable a => Closure (ConduitT () a (ResourceT IO) ()) -> Partition a

-- | Create a dataset from given <a>Partition</a>'s.
dExternal :: StaticSerialise a => [Partition a] -> Dataset a
class (Typeable a, Serialise a) => StaticSerialise a
staticSerialise :: StaticSerialise a => Closure (Dict (Typeable a, Serialise a))
class (Typeable a, Eq a, Hashable a) => StaticHashable a
staticHashable :: StaticHashable a => Closure (Dict (Typeable a, Eq a, Hashable a))

-- | On distributed-fork, we run the same binary both in your machine
--   (called "driver") and in the remote environment (called "executor").
--   In order for the program to act according to where it is, you should
--   call this function as the first thing in your <tt>main</tt>:
initDistributedFork :: IO ()

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | Type of serializable closures. Abstractly speaking, a closure is a
--   code reference paired together with an environment. A serializable
--   closure includes a <i>shareable</i> code reference (i.e. a
--   <a>StaticPtr</a>). Closures can be serialized only if all expressions
--   captured in the environment are serializable.
data Closure a

-- | Closure application. Note that <a>Closure</a> is not a functor, let
--   alone an applicative functor, even if it too has a meaningful notion
--   of application.
cap :: Typeable a => Closure (a -> b) -> Closure a -> Closure b

-- | A closure can be created from any serializable value. <a>cpure</a>
--   corresponds to <a>Control.Applicative</a>'s <a>pure</a>, but
--   restricted to lifting serializable values only.
cpure :: Closure (Dict (Serializable a)) -> a -> Closure a

-- | Values of type <tt><a>Dict</a> p</tt> capture a dictionary for a
--   constraint of type <tt>p</tt>.
--   
--   e.g.
--   
--   <pre>
--   <a>Dict</a> :: <a>Dict</a> (<a>Eq</a> <a>Int</a>)
--   </pre>
--   
--   captures a dictionary that proves we have an:
--   
--   <pre>
--   instance <a>Eq</a> 'Int
--   </pre>
--   
--   Pattern matching on the <a>Dict</a> constructor will bring this
--   instance into scope.
data Dict a
[Dict] :: forall a. a => Dict a
